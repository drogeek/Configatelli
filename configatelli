#!/usr/bin/python3

from pathlib import Path
from contextlib import contextmanager
import xml.etree.ElementTree as etree
import os
from subprocess import call
import argparse as ap
from hashlib import sha1
from shutil import copy,Error
from getpass import getpass
from pbkdf2 import PBKDF2
from Crypto.Cipher import AES
from Crypto.Util import Counter
import os

@contextmanager
def cd(path):
    try:
        old=os.getcwd()
        os.chdir(path)
        yield
    except FileNotFoundError:
        print("File not found")
    finally:
        os.chdir(old)

alreadyExist = lambda root,location,name : root.find('.//entry/[name="{}"][location="{}"]'.format(name,location)) != None

OUTPUT_FILE = 'locations.xml'
PASSWORD_FILE = '.passwd.txt'
## CHECK/CREATE CONFIG
CONF_DIR = Path.home().joinpath('.config/configatelli')
if not CONF_DIR.exists():
    os.mkdir(CONF_DIR.as_posix())
    with cd(CONF_DIR.as_posix()):
        root = etree.Element('config')
        with open(OUTPUT_FILE,'xb') as f:
            f.write(etree.tostring(root))


## CHECK/CREATE CONFIG
DATA_DIR = Path.home().joinpath('.local/share/configatelli')
if not DATA_DIR.exists():
    os.mkdir(DATA_DIR.as_posix())
        
def getTree(f):
    if not Path(f).exists():
        root = etree.Element('config')
        with open(f,'xb') as f:
            f.write(etree.tostring(root))
    return etree.parse(f)

def decorator_cd(f):
    def wrapper(args):
        with cd(CONF_DIR.as_posix()):
            f(args)
    return wrapper

def hashData(path):
    result = sha1()
    with open(path,'rb') as f:
        for chunk in iter(lambda: f.read(4096), b''):
            result.update(chunk)
    return result

def resolvePath(f):
    try:
        return Path(f).absolute().resolve().as_posix()
    except FileNotFoundError:
        print("{} wasn't found".format(f))

def store(args):
    args_files = [ resolvePath(f) for f in args.files ]
    with cd(CONF_DIR.as_posix()):
       #we resolve the full path
        for args_file in filter(lambda x: x != None, args_files):
            file_path = Path(args_file).parent.as_posix()
            file_name = Path(args_file).name
            hash_file_name = sha1(args_file.encode('utf-8')).hexdigest()
            hash_data = hashData(args_file).hexdigest()

                        
            tree = getTree(OUTPUT_FILE)
            root = tree.getroot()

            if alreadyExist(root,file_path,file_name):
                stored_hash_data=root.find('.//entry/[name="{}"][location="{}"]/hdata'.format(file_name,file_path))
                if hash_data != stored_hash_data.text:
                    #TODO: commit changes
                    stored_hash_data.text=hash_data
                    tree.write(OUTPUT_FILE)
                    if not args.encrypt:
                        with cd(DATA_DIR.as_posix()):
                            call(['cp', args_file, hash_file_name])
                            print('{} updated'.format(file_name))
                    else:
                    #TODO: remove previously non encrypted file from git history?
                        key=getKey()
                        with open(args_file,'rb') as fileToEncrypt:
                            cipher = AES.new(key, AES.MODE_CTR, counter=Counter.new(128))
                            encrypted = cipher.encrypt(fileToEncrypt.read())
                            with open(DATA_DIR.joinpath(hash_file_name).as_posix(),'wb+') as encryptedFile:
                                encryptedFile.write(encrypted)
                                print("file {} successfully encrypted and stored".format(args_file))
                                
                else:
                    print("{} hasn't changed".format(file_name))

            else:
                entryelem = etree.SubElement(root,'entry')
                locationelem = etree.SubElement(entryelem,'location')
                locationelem.text = file_path
                nameelem = etree.SubElement(entryelem,'name')
                nameelem.text = file_name
                hashDataelem = etree.SubElement(entryelem,'hdata')
                hashDataelem.text=hash_data
                encrypelem = etree.SubElement(entryelem,'encrypted')
                encrypelem.text = str(args.encrypt)
                tree.write(OUTPUT_FILE)
                with cd(DATA_DIR.as_posix()):
                    call(['cp', args_file, hash_file_name])
                    print('{} stored'.format(file_name))

@decorator_cd
def deploy(args):
    #get encrypted ones, decrypt them and deploy them
    #then deploy the others
    tree = getTree(OUTPUT_FILE)
    root = tree.getroot()
    for elem in root.findall('entry'):
        name = elem.find('name').text
        location = elem.find('location').text
        nameLocation = '/'.join([location,name])
        hash_file_name = sha1(nameLocation.encode('utf-8')).hexdigest()
        try:
            copy('/'.join([DATA_DIR.as_posix(),hash_file_name]),nameLocation)
            print("copying to {}".format(nameLocation))
        except FileNotFoundError:
            #TODO: check in git history?
            print("file '{}' doesn't exist".format(name))

def askCreationUserPassword():
    pwd=''
    while pwd == '' or pwd != retypedPwd:
        pwd = getpass('Create your password: ')
        retypedPwd = getpass('Retype your password: ')
    return pwd

def askUserPassword():
    return getpass('Enter your password: ')

#returns a 256-bit key
def createKey(pwd,salt=os.urandom(8)):
    key = PBKDF2(pwd, salt,iterations=10000).read(32)
    return (salt,key)

#get the salt, and create the key along with it if it didn't exist already
def getKey():
    #test if the password exists
    #TODO: store it with the git repo
    passwd_file = Path.cwd().joinpath(PASSWORD_FILE)
    if passwd_file.exists():
        with open(passwd_file.as_posix(),'rb') as pf:
            salt=pf.read()
            pwd=askUserPassword()
            _,key = createKey(pwd,salt)
    #creation of passwd to encrypt
    else:
        pwd=askCreationUserPassword()
        salt,key = createKey(pwd)
        with open(passwd_file.as_posix(),'wb+') as pf:
            pf.write(salt)
    return key

mainparser = ap.ArgumentParser(prog="configatelli", description="manage your config files")
subparser = mainparser.add_subparsers(help="subcommand help")
subparser.required = True
subparser.dest = 'command'

store_parser = subparser.add_parser('store', help="store config files")
store_parser.add_argument("files", nargs='+', help="the files to store")
store_parser.add_argument("-e", "--encrypt", help="encrypt the file", action="store_true")
store_parser.add_argument("-y", "--yes", help="automatically update the file if it exists", action="store_true")
store_parser.set_defaults(func=store)

deploy_parser = subparser.add_parser('deploy', help="deploy config files")
deploy_parser.add_argument("-v", "--verbose", action="store_true")
deploy_parser.set_defaults(func=deploy)

args = mainparser.parse_args()
args.func(args)
