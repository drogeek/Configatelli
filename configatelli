#!/usr/bin/python3

from pathlib import Path
from contextlib import contextmanager
import xml.etree.ElementTree as etree
import os
from subprocess import call
import argparse as ap
from hashlib import sha1
from shutil import copy,Error
from getpass import getpass
from pbkdf2 import PBKDF2
from Crypto.Cipher import AES
from Crypto.Util import Counter
import os

#TODO: generic for path ($HOME) and store hash of the abstraction, not the real one (otherwise it's going to change from one user name to another)
@contextmanager
def cd(path):
    try:
        old=os.getcwd()
        os.chdir(path)
        yield
    except FileNotFoundError:
        print("File not found")
    finally:
        os.chdir(old)

alreadyExist = lambda root,location,name : root.find('.//entry/[name="{}"][location="{}"]'.format(name,location)) != None

OUTPUT_FILE = 'locations.xml'
PASSWORD_FILE = '.passwd.txt'
## CHECK/CREATE CONFIG
CONF_DIR = Path.home().joinpath('.config/configatelli')
if not CONF_DIR.exists():
    os.mkdir(CONF_DIR.as_posix())

if not CONF_DIR.joinpath(OUTPUT_FILE).exists():
    with cd(CONF_DIR.as_posix()):
        root = etree.Element('config')
        with open(OUTPUT_FILE,'xb') as f:
            f.write(etree.tostring(root))


## CHECK/CREATE CONFIG
DATA_DIR = Path.home().joinpath('.local/share/configatelli')
if not DATA_DIR.exists():
    os.mkdir(DATA_DIR.as_posix())
        
def getTree(f):
    if not Path(f).exists():
        root = etree.Element('config')
        with open(f,'xb') as f:
            f.write(etree.tostring(root))
    return etree.parse(f)

def decorator_cd(f):
    def wrapper(args):
        with cd(CONF_DIR.as_posix()):
            f(args)
    return wrapper

def hashData(path):
    result = sha1()
    with open(path,'rb') as f:
        for chunk in iter(lambda: f.read(4096), b''):
            result.update(chunk)
    return result

def resolvePath(f):
    try:
        return Path(f).absolute().resolve().as_posix()
    except FileNotFoundError:
        print("{} wasn't found".format(f))

def encryptFile(path,name):
    key=getKey()
    with open(path,'rb') as fileToEncrypt:
        cipher = AES.new(key, AES.MODE_CTR, counter=Counter.new(128))
        encrypted = cipher.encrypt(fileToEncrypt.read())
        with open(DATA_DIR.joinpath(name).as_posix(),'wb+') as encryptedFile:
            encryptedFile.write(encrypted)
            print('{} stored encrypted as {}'.format(path,name))

def store(args):
    args_files = [ resolvePath(f) for f in args.files ]
    with cd(CONF_DIR.as_posix()):
       #we resolve the full path
        for args_file in filter(lambda x: x != None, args_files):
            file_path = Path(args_file).parent.as_posix()
            file_name = Path(args_file).name
            hash_file_name = sha1(args_file.encode('utf-8')).hexdigest()
            hash_data = hashData(args_file).hexdigest()

                        
            tree = getTree(OUTPUT_FILE)
            root = tree.getroot()

            if alreadyExist(root,file_path,file_name):
                stored_elem=root.find('.//entry/[name="{}"][location="{}"]'.format(file_name,file_path))
                stored_encryption_status=stored_elem.find('encrypted')
                stored_hash_data=stored_elem.find('hdata')
                if stored_encryption_status.text != str(args.encrypt) or hash_data != stored_hash_data.text:
                    #TODO: commit changes
                    if not args.encrypt:
                        with cd(DATA_DIR.as_posix()):
                            call(['cp', args_file, hash_file_name])
                            print('{} stored as {}'.format(args_file,hash_file_name))
                    else:
                    #TODO: remove previously non encrypted file from git history?
                        encryptFile(args_file,hash_file_name)
                    stored_hash_data.text=hash_data
                    stored_encryption_status.text=str(args.encrypt)
                    tree.write(OUTPUT_FILE)
           
                else:
                    print("{} hasn't changed".format(file_name))

            else:
                entryelem = etree.SubElement(root,'entry')
                locationelem = etree.SubElement(entryelem,'location')
                locationelem.text = file_path
                nameelem = etree.SubElement(entryelem,'name')
                nameelem.text = file_name
                hashDataelem = etree.SubElement(entryelem,'hdata')
                hashDataelem.text=hash_data
                encrypelem = etree.SubElement(entryelem,'encrypted')
                encrypelem.text = str(args.encrypt)
                tree.write(OUTPUT_FILE)
                with cd(DATA_DIR.as_posix()):
                    if not args.encrypt:
                        call(['cp', args_file, hash_file_name])
                    else:
                        encryptFile(args_file,hash_file_name)
                    print('{} stored as {}'.format(args_file,hash_file_name))

@decorator_cd
def deploy(args):
    #get encrypted ones, decrypt them and deploy them
    #then deploy the others
    tree = getTree(OUTPUT_FILE)
    root = tree.getroot()
    if root.findall('.//entry/[encrypted="True"]') != None:
        print('Encrypted files found')
        key=getKey()
               
    for elem in root.findall('entry'):
        name = elem.find('name').text
        location = elem.find('location').text
        encrypted = elem.find('encrypted').text
        nameLocation = '/'.join([location,name])
        hash_file_name = sha1(nameLocation.encode('utf-8')).hexdigest()
        if encrypted == 'True':
             with open('/'.join([DATA_DIR.as_posix(),hash_file_name]),'rb') as fileToDecrypt:
                cipher = AES.new(key, AES.MODE_CTR, counter=Counter.new(128))
                decrypted = cipher.decrypt(fileToDecrypt.read())
                with open(nameLocation,'wb+') as decryptedFile:
                    decryptedFile.write(decrypted)
                    print("file {} successfully decrypted".format(name))
                    print("copying to {}".format(nameLocation))
                            
        else:
            try:
                copy('/'.join([DATA_DIR.as_posix(),hash_file_name]),nameLocation)
                print("copying to {}".format(nameLocation))
            except FileNotFoundError:
                #TODO: check in git history?
                print("file '{}' doesn't exist".format(name))

def askCreationUserPassword():
    pwd=''
    while pwd == '' or pwd != retypedPwd:
        pwd = getpass('Create your password: ')
        retypedPwd = getpass('Retype your password: ')
    return pwd

def askUserPassword():
    #TODO: verify the password is correct
    return getpass('Enter your password: ')

#returns a 256-bit key
def createKey(pwd,salt=os.urandom(8)):
    key = PBKDF2(pwd, salt,iterations=10000).read(32)
    return (salt,key)

#get the key and create a random salt if it didn't exist already
def getKey():
    #test if the password exists
    #TODO: store it with the git repo
    with cd(DATA_DIR.as_posix()):
        passwd_file = Path.cwd().joinpath(PASSWORD_FILE)
        if passwd_file.exists():
            with open(passwd_file.as_posix(),'rb') as pf:
                salt=pf.read()
                pwd=askUserPassword()
                _,key = createKey(pwd,salt)
        #creation of passwd to encrypt
        else:
            pwd=askCreationUserPassword()
            salt,key = createKey(pwd)
            with open(passwd_file.as_posix(),'wb+') as pf:
                pf.write(salt)
        return key

mainparser = ap.ArgumentParser(prog="configatelli", description="manage your config files")
subparser = mainparser.add_subparsers(help="subcommand help")
subparser.required = True
subparser.dest = 'command'

store_parser = subparser.add_parser('store', help="store config files")
store_parser.add_argument("files", nargs='+', help="the files to store")
store_parser.add_argument("-e", "--encrypt", help="encrypt the file", action="store_true")
store_parser.add_argument("-y", "--yes", help="automatically update the file if it exists", action="store_true")
store_parser.set_defaults(func=store)

deploy_parser = subparser.add_parser('deploy', help="deploy config files")
deploy_parser.add_argument("-v", "--verbose", action="store_true")
deploy_parser.set_defaults(func=deploy)

args = mainparser.parse_args()
args.func(args)
